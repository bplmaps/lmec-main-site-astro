---
import { storyblokEditable } from '@storyblok/astro';
import { RichTextSchema, renderRichText } from '@storyblok/js';
import StoryblokComponent from '@storyblok/astro/StoryblokComponent.astro';

export interface Props {
  blok: {
    body: any;
  };
}

const { blok } = Astro.props;

// Initialize a Map to store nestable blocks with unique markers
const nestableBlocks = new Map();

// Render the rich text content with our custom schema
let renderedContent = '';
try {
  renderedContent = renderRichText(blok.body, {
    schema: RichTextSchema,
    resolver: (component, blok) => {
      switch (component) {
        case "html-block":
          return `<div class="html-block">${blok.rawHTML}</div>`;
          break;
        default:
          return `Component ${component} not found`;
      }
    },
  }) ?? '';
} catch (error) {
  console.error('Error rendering rich text:', error);
  renderedContent = '<p>Error rendering content</p>';
}

// Split the rendered content by block markers
interface ContentPart {
  type: 'html' | 'blok';
  content?: string;
  blok?: any;
}

const contentParts: ContentPart[] = [];
const parts = renderedContent.split(/(__BLOCK_[a-zA-Z0-9]+__)/g);

parts.forEach(part => {
  if (part.startsWith('__BLOCK_') && part.endsWith('__')) {
    // This is a block marker, get the corresponding block
    const block = nestableBlocks.get(part);
    if (block) {
      contentParts.push({ type: 'blok', blok: block });
    }
  } else if (part.trim()) {
    // This is HTML content (non-empty)
    contentParts.push({ type: 'html', content: part });
  }
});
---

<div {...storyblokEditable(blok)}>
  {contentParts.map((part, index) => {
    if (part.type === 'html') {
      return <div set:html={part.content} class="rich-text-content" />;
    } else if (part.type === 'blok' && part.blok) {
      return <StoryblokComponent blok={part.blok} />;
    }
    return null;
  })}
</div>