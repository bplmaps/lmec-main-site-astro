---
import { storyblokEditable } from '@storyblok/astro';
import { richTextResolver } from '@storyblok/richtext';
import AlertBox from './nestable/AlertBox.astro';
import Button from './nestable/Button.astro';
import CardHolder from './nestable/CardHolder.astro'
import Carousel from './nestable/Carousel.astro';
import CartographyChallenges from './nestable/CartographyChallenges.astro';
import UnionSearch from './nestable/UnionSearch.astro';
import EducationListing from './nestable/EducationListing.astro';
import EventTagListing from './nestable/EventTagListing.astro';
import ExhibitionEvents from './nestable/ExhibitionEvents.astro';
import Figure from './nestable/Figure.astro';
import GrantInAid from './nestable/GrantInAid.astro';
import HoursTable from './nestable/HoursTable.astro';
import HtmlBlock from './nestable/HtmlBlock.astro';
import SmallGrants from './nestable/SmallGrants.astro';
import StaffList from './nestable/StaffList.astro';

export interface Props {
  blok: {
    body: any;
  };
}

const { blok } = Astro.props;
const { render } = richTextResolver();

const mergeAdjacentLinks = (html: string): string => {
  // Safety check: return original if input is invalid
  if (!html || typeof html !== 'string') {
    return html;
  }
  
  let result = html;
  let modified = true;
  let iterations = 0;
  const MAX_ITERATIONS = 100; // Prevent infinite loops
  
  // Keep looping until no more adjacent links can be merged
  while (modified && iterations < MAX_ITERATIONS) {
    modified = false;
    iterations++;
    
    try {
      // Pattern to match: </a> followed by <a> (with possible inline tags and whitespace between)
      const adjacentLinkPattern = /<\/a>((?:<(?:em|strong|i|b|span|sup|sub)[^>]*>|<\/(?:em|strong|i|b|span|sup|sub)>|\s)*)<a\s+([^>]+)>/g;
      
      const tempResult = result.replace(adjacentLinkPattern, (match, betweenTags, secondAttrs, offset) => {
        try {
          // Find the opening tag of the first link by looking backwards
          const beforeMatch = result.substring(0, offset);
          const firstLinkMatch = beforeMatch.match(/<a\s+([^>]+)>(?:(?!<a\s+)[\s\S])*?$/);
          
          if (!firstLinkMatch) return match;
          
          const firstAttrs = firstLinkMatch[1];
          
          // Extract href from both links - be defensive about attribute format
          const href1Match = firstAttrs.match(/href\s*=\s*["']([^"']+)["']/);
          const href2Match = secondAttrs.match(/href\s*=\s*["']([^"']+)["']/);
          
          const href1 = href1Match ? href1Match[1] : null;
          const href2 = href2Match ? href2Match[1] : null;
          
          // Only merge if both hrefs exist and match exactly
          if (href1 && href2 && href1 === href2) {
            // Additional safety: check that attributes are substantially similar
            // (same target, same data-popup, etc.)
            const target1 = firstAttrs.match(/target\s*=\s*["']([^"']+)["']/)?.[1];
            const target2 = secondAttrs.match(/target\s*=\s*["']([^"']+)["']/)?.[1];
            const popup1 = firstAttrs.match(/data-popup\s*=\s*["']([^"']+)["']/)?.[1];
            const popup2 = secondAttrs.match(/data-popup\s*=\s*["']([^"']+)["']/)?.[1];
            
            // Only merge if key attributes match (or both are undefined)
            if (target1 === target2 && popup1 === popup2) {
              modified = true;
              // Remove the </a> and <a> tags, keep the content between
              return betweenTags;
            }
          }
          
          return match;
        } catch (innerError) {
          // If anything goes wrong processing this match, return it unchanged
          console.warn('Error processing link match:', innerError);
          return match;
        }
      });
      
      result = tempResult;
    } catch (error) {
      // If the entire replacement fails, log and return what we have so far
      console.error('Error in mergeAdjacentLinks:', error);
      break;
    }
  }
  
  // Warn if we hit max iterations (might indicate a problem)
  if (iterations >= MAX_ITERATIONS) {
    console.warn('mergeAdjacentLinks hit maximum iterations, stopping to prevent infinite loop');
  }
  
  return result;
};

const renderComponent = (component: any) => {
  switch(component.component) {
    case 'alert-box':
      return { type: 'AlertBox', props: component };
    case 'button':
      return { type: 'Button', props: component };
    case 'carousel':
      return { type: 'Carousel', props: component };
    case 'card-holder':
      return { type: 'CardHolder', props: component };
    case 'cartography-challenges':
      return { type: 'CartographyChallenges', props: component };
    case 'digital-collections-union-search':
      return { type: 'UnionSearch', props: component };
    case 'education-listing':
      return { type: 'EducationListing', props: component };
    case 'event-tag-listing':
      return { type: 'EventTagListing', props: component };
    case 'exhibition-events':
      return { type: 'ExhibitionEvents', props: component };
    case 'figure':
      return { type: 'Figure', props: component };
    case 'grant-in-aid':
      return { type: 'GrantInAid', props: component };
    case 'hours-table':
      return { type: 'HoursTable', props: component };
    case 'html-block':
      return { type: 'HtmlBlock', props: component };
    case 'small-grants':
      return { type: 'SmallGrants', props: component };
    case 'staff-list':
      return { type: 'StaffList', props: component };
    default:
      return { type: 'unknown', props: component };
  }
};

const renderNode = (node: any) => {
  if (node.type === 'blok') {
    return node.attrs.body.map((component: any) => renderComponent(component));
  }

  try {
    if (node.type === 'paragraph' && node.content) {
      node.content.map((item: any) => {
        if (item.type === 'text') {
          item.text = item.text === null ? '' : item.text;
        }

        return item;
      });
    }

    // Pass the node directly to render - it already has the required type property
    let content = render(node) as string;
    
    if (!content || content.trim() === '') {
      return [];
    }

    // Replace inline markdown-formatted footnotes with superscripts
    content = content.replaceAll(/\[\^(\d+)\](?!:)/gm, '<sup><a href="#fn:$1" data-footnote="$1" class="footnote-ref" role="doc-noteref">$1</a></sup>');
    
    // Replace markdown-formatted endnotes with decimal-formatted list
    content = content.replaceAll(/\[\^(\d+)\]:/gm, '<span id="fn:$1" data-endnote="$1" role="doc-endnote">$1.</span>');

    // Merge adjacent links with the same href
    content = mergeAdjacentLinks(content);

    return { type: 'html', content };
  } catch (error) {
    console.error('Error rendering node:', node, error);
    return [];
  }
};

const richTextNodes = (blok.body?.content || []).filter((node: { type: any; }) => node && node.type);
const processedNodes = richTextNodes.flatMap(renderNode);
---

<div {...storyblokEditable(blok)}>
  {processedNodes.map((item: any) => {
    if (item.type === 'html') {
      return <Fragment set:html={item.content} />;
    }
    
    switch(item.type) {
      case 'AlertBox':
        return <AlertBox blok={item.props} />;
      case 'Button':
        return <Button blok={item.props} />;
      case 'Carousel':
        return <Carousel blok={item.props} />;
      case 'CardHolder':
        return <CardHolder blok={item.props} />;
      case 'CartographyChallenges':
        return <CartographyChallenges blok={item.props} />;
      case 'UnionSearch':
        return <UnionSearch blok={item.props} />;
      case 'EducationListing':
        return <EducationListing blok={item.props} />;
      case 'EventTagListing':
        return <EventTagListing blok={item.props} />;
      case 'ExhibitionEvents':
        return <ExhibitionEvents blok={item.props} />;
      case 'Figure':
        return <Figure blok={item.props} />;
      case 'GrantInAid':
        return <GrantInAid blok={item.props} />;
      case 'HoursTable':
        return <HoursTable blok={item.props} />;
      case 'HtmlBlock':
        return <HtmlBlock blok={item.props} />;
      case 'SmallGrants':
        return <SmallGrants blok={item.props} />;
      case 'StaffList':
        return <StaffList blok={item.props} />;
      default:
        return `<!-- Unknown component: ${item.props.component} -->`;
    }
  })}
</div>